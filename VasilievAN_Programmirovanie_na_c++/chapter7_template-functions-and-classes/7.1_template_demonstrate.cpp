/*
 * =====================================================================================
 *
 *       Filename:  7.1_template_demonstrate.cpp
 *
 *    Description:  demonstrates a template paradigm 
 *
 *        Version:  1.0
 *        Created:  06/20/20 17:17:49
 *       Revision:  none
 *       Compiler:  g++
 *
 *         Author:  Artur
 *   Organization:  
 *
 * =====================================================================================
 */
#include <iostream>
using namespace std;


template<class X> void show(X thing)   // template - это полезная вещь,
{                                      //   позволяющая работать одной функции
   cout << thing << endl;              //   с разными типами. Ты как-бы
}                                      //   говоришь функции подстраиваться под
                                       //   аргументы. На самом деле эта вещь
                                       //   нужна для человека, чтобы не
                                       //   грамоздить кучи перегруженных
                                       //   функций. На деле же комплилятор
                                       //   плодит их при каждом новом случае
                                       // class X - это такая замена типа. на
                                       //   это место X может прийти int, может
                                       //   char, а может даже что-то
                                       //   кастомное. Главное, чтобы код в
                                       //   функции не сломал зубы о такой
                                       //   аргумент. Часто вместо слова class
                                       //   пишут более интуитивное typename.
                                       //   Это относительно новое ключевое
                                       //   слово, но цель у него та же
// В чём разнице между char* и char[]? Лучше сразу показать кодом:
// char *str_1 = "sometext";
// char str_2[] = "sometext";
// str_1[6] = 's';    // ERROR: нельзя изменить что-то в области памяти для
//                    // констант
// str_2[6] = 's';    // А здесь можно, т.к. str_2 - это настоящий массив.
//                    // Компилятор уже выделил столько памяти, сколько
//                    // нужно было для "sometext\0", и копировал это всё
//                    // в стёк. И ещё не стоит забывать про эффект распада
//                    // массива. Т.е. sizeof() для str_1 выдаст 8, а для
//                    // str_2 - 9
int main()
{
   show('V');      // show(char) - где-то здесь компилятор увидел, что фукнции
   show(42);       //   show(), принимающей char, нету. Это знак, что надо
   show("timber"); //   такую создать.
                   // show(int) - такой тоже нету, значит тоже сделаем
                   // show(char) - здесь та же схема
   show<const char*>("delight"); // <> - здесь тоже можно явно задавать тип
   return 0;                     //   параметра шаблона. Главное, чтобы
}                                //   аргумент самой функции подходил под него
// volatile - этот квалификатор нужен для того, чтобы компилятор не шаманил над
//   какой-либо переменной, пытаясь ускорить работу там, где она используется.
//   volatile незаменим там, где переменную может менять что-то извне
//   (например, другой поток или, скажем, другой процесс)
