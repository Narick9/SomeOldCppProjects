/*
 * =====================================================================================
 *
 *       Filename:  7.11_template-int-param_polynom.cpp
 *
 *    Description:  describes polynom as class 
 *
 *        Version:  1.0
 *        Created:  06/23/2020 12:50:18 PM
 *       Revision:  none
 *       Compiler:  g++
 *
 *         Author:  Artur
 *   Organization:  
 *
 * =====================================================================================
 */
#include <iostream>
using namespace std;


template< int power >   // int - параметры шаблона, как правило, обозначают
class Polynom {         //   тип. Но есть и исключение - они могут принимать
                        //   число (но только то, которое может знать
                        //   комплилятор, т.е. константу). Здесь это полезно,
                        //   т.к. мы хотим иметь в классе статический массив
   int a[power + 1];    // + 1 - об этом уже говорилось, но полином (как и 
   public:              //   многочлен) - это a + ax + ax^2 + ax^3 ... Значит,
                        //   a-элементов на 1 больше, чем максимальная степень
      Polynom<power>() {
         for (int i = 0; i <= power; i++)
            a[i] = 0;
      }
      Polynom(int nums[power+1]) {
         for (int i = 0; i <= power; i++)
            a[i] = nums[i];
      }

      void print() const {             // const - да, квалифицировать можно не
         cout << "|";                  //   только переменные. const у методов
         for (const int &x: a)         //   говорит о том, что этот метод не
            cout << " " << x << " |";  //   может изменить члены класса. Если
         cout << endl;                 //   this у обычных методов имеет вид
      }                                //   obj* const,  то у методов с
                                       //   квалификатором const вид немного
                                       //   меняется: const obj* const. Сюда же
                                       //   отностися и квалификатор mutable у
                                       //   полей класса, который даёт
      int operator()(int x) const {    //   возмножность даже const методам
         int sum = 0;                  //   менять себя. Похоже на
         int q = 1;                    //   искусственную сложность? - Да
         for (int i = 0; i <= power; i++) {
            sum += a[i] * q;
            q *= x;
         }
         return sum;
      }
      int& operator[](int i) {
         return a[i];
      }                 // <> - здесь это может быть неочевидно, но шаблонные
      template< int n > //   методы работают как шаблонные функции
      Polynom<power+n> operator* (Polynom<n> right) const {
         Polynom<power+n> ans;
         for (int i = 0; i <= power; i++)
            for (int k = 0; k <= n; k++)
               ans[i + k] += a[i] * right[k];   // i + k - здесь сидит немного
         return ans;                            //   неочевидная формула. Лучше
      }                                         //   представить всё на бумаге
      template< int n >
      Polynom<(n>power)?n:power> operator+ (Polynom<n> right) const {
         Polynom<(n>power)?n:power> ans;
         for (int i = 0; i <= power; i++)
            ans[i] += a[i];            // a[] - можно было бы писать (*this)[],
         for (int i = 0; i <= n; i++)  //   если бы метод был не с const. g++
            ans[i] += right[i];        //   видит, что ты пытаешься сжульничать
         return ans;                   //   , и выводит error
      }
};
template< int power >
Polynom<power> operator* (Polynom<power> left, int right)
{
   Polynom<power> ans;
   for (int i = 0; i <= power; i++)
      ans[i] = left[i] * right;
   return ans;
}
template< int power >
Polynom<power> operator* (int left, Polynom<power> right)   // left-right///
{
   return right * left;
}
template< int l_pow, int r_pow >
Polynom<(l_pow>r_pow)?l_pow:r_pow> operator- (Polynom<l_pow> left,
                                              Polynom<r_pow> right)
{
   return left + -1*right;    // -1 - да, это работает так. Но лучше так не
}                             //   делать. Особенно если это будет читать
                              //   кто-то другой

template< int power >
Polynom<power-1> diff(Polynom<power> obj)
{
   Polynom<power-1> ans;
   for (int i = 0; i <= power - 1; i++) {
      ans[i] = obj[i + 1] * (i + 1);
   }
   return ans;
}  // protected - поля класса, объявленные таким модификатором доступа
   //   недоступны извне класса, но зато прекрасно наследуются, оставаясь
   //   protected при protected и public наследовании (private-наследование
   //   просто всё приватит). Чем отличается public-наследование от protected
   //   наследования? При protected наследовании и public, и protected члены
   //   становятся protected (public же всё оставляет как есть)
   // casts - в C++ есть 5 типов явных преобразований:
                                 void _() {
   /*   C-style cast:          */   float ans = (float)5 / 3;
   /*   в C++ можно даже так:  */   ans = (float)5 / 3;
   //   Работает интуитивно, но по меркам C++ небезопасно, т.к. так можно
   //   менять типы const переменных, да и вообще легко можно переводить
   //   8-байтные типы к 1-байтным. Компилятор это не контролирует.
   /*   static_cast:           */   ans = static_cast<float>(5) / 3;
   //   А это уже универсальный способ. Если что-то будет не так, компилятор
   //   не заркоет на это глаза.
                                    float temp = 2.25;
                                    const float *p_con = &temp;
   /*   const_cast:            */   float *p_temp = const_cast<float*>(p_con);
   //   Это как const_cast, только для перевода const-nonconst. Из типа в тип
   //   переводить он не умеет.
   /*   dynamic_cast:          */
   //   Примера не будет, но суть такова: если у нас есть указатель на класс-
   //   -родитель, хранящий класс-потомок, и нам нужно что-то из класса потомка
   //   , то можно воспользоваться этой штукой для преобразования указателя.
   //   Такая операция называется понижающим приведением (ещё есть повышающее),
   //   ну или приведением к дочернему типу. Видимо, это повсеметная практика -
   //   использование указателя на класс родитель для хранения класса-потомка.
   //   Если привести тип нельзя, то const_cast вернёт NULL. Стоит делать
   //   проверки.
   /*   reinterpret_cast       */   int *p_i = reinterpret_cast<int*>(777);
   //   Эта штука уже почти без ограничений, т.к. не смотрит на типы, а только
   //   на их размер в памяти. Вся с этим ответственность лежит на человеке.
   //   Каждый из этих способов способен работать и с ссылкой, но стоит помнить
   //   , что ссылка может приводиться только к ссылке. Также следует всегда
   //   делать проверки. Даже reinterpret_cast может вернуть что-то неожиданное
                                 }
   // typeof() - не входит ни в Си, ни в C++. Идёт из компиляторов семьи gcc.
   //   Это значит, что тип этот оператор достаёт ещё при компиляции
   // typeid() - только в C++. подрубается через #include <typeinfo>. Выдаёт
   //   не сам тип, а объект класса type_info. Через его методы уже можно
   //   получить нужную информацию (например, name() выдаёт первый символ типа)
   // static в классах - тут логика static такая-же, как и везде - static-
   //   -переменная существует как-бы вне класса, поэтому её можно использовать
   //   даже без создания объектов класса - просто через ClassName::static_int.
   //   Все объекты этого класса будут иметь доступ в одну и ту же переменную:
   //   изменит кто-то один - изменятся у всех. static-методы тоже, как и
   //   переменные, могут вызывать даже если не создано ни одного объекта
   //   данного класса. Правда, это значит, что они не могут использовать
   //   не static-поля. У них просто нет this как у обычных методов. Вообще,
   //   можно создавать классы чисто состоящие из static-объектов. Получится
   //   что-то вроде местного островка области видимости со своей экосистемой.
   //   И методы, и члены такого класса достаются через ClassName::thing.
   // friend - этим ключевым словом в классах можно задавать дружественные
   //   функции, т.е. им открыт доступ к private полям:
        class Thing {
           int val;
           friend void set_it(Thing& obj);
        };
        void set_it(Thing& obj)
        {
           obj.val = 5;
        }
   //   Здесь у нас есть класс, и мы сказали ему, что функция set_it - это друг
   //   , и ей можно доверять свои private поля. Одна функция может быть другом
   //   сразу у многих классов. Да даже целый класс может быть другом другого
   //   класса. Даже не обязательно, чтобы эта дружба была взаимной:
        class Bravo;
        class Alpha {
           int alpha;
           friend class Bravo;
        };
        class Bravo {
           void print_alpha(Alpha obj) {
              cout << obj.alpha << endl;
           }
        };
   //   Здесь начинка класса Bravo имеет полный доступ к начинке Alpha. Правда,
   //   для общения классов совсем не обязательно чтобы они дружили полностью.
   //   Достаточно подружить их методы через оператор расширения контекста (::)
   //   . Лучше использовать friend там, где это действительно необходимо, а не
   //   нарушать принципы инкапсуляции везде, где можно
   // typename - как замена слову class в template эта штука понятна, но
   //   создано оно не для этого. Допустим, есть такая вот функция:
        template< class T >
        void foo(T obj)
        {
   //      T::qwer *x;
           /*      ...      */
        }
   //   что такое qwer? Компилятор не вкурсе. Это может быть простой переменной
   //   (тогда получается, что мы хотим qwer умножить на x), а может быть и
   //   типом, как здесь (ещё такое часто можно встретить в шаблонах STL):
        template< class T >
        class Point {
           public:
              typedef T qwer;   // typedef - его используем, т.к. нужно
              qwer x;           //   сохранить шаблонный параметр, т.к. он
              qwer y;           //   забудется сразу после компиляции
        };
   //   Чтобы облегчить жизнь компилятору, следовало явно написать перед
   //   T::qwer ключевое слово typename:
        template< class Y >
        void bar(Y obj)
        {
           typename Y::value_type *x;
           /*      ...      */
        }
   //   так мы явно тыкаем компилятору, что это всё-таки тип. Почему компилятор
   //   не знает что скрывается под оборткой T::qwer, если он ещё во время
   //   компиляции распарсивает все шаблоны? Дело в том, что на самом
   //   деле он не может переделать шаблонную функцию в её частные случаи
   //   (к которым появляется нужда при вызове такой шаблонной функции с уже
   //   конкретными типами), пока не поймёт как она работает (что там: тип или
   //   переменная?)
   // #difene - есть старый приём, использовавшийся в Си. Он оригенален и
   //   неожидан, как и всё в Си:
        #define DEFINE_CONTAINER(N,T,S)   \
        typedef struct N ## Container {   \
           int size;                      \
           T arr[S];                      \
        } N ## Container;
   //   ## здесь нужен для соединения аргумента N и слова Container.
   //   Выглядело это так:
        DEFINE_CONTAINER(Int, int, 12)
        IntContainer apple_series;
   //   Конечно, щас таким лучше не заниматься, если твой код будет читать
   //   кто-то ещё, ведь template выглядит менее страшно
   // f - чтобы лишний раз помочь компилятору, можно задавать сразу после
   //   значения, которые чему-то присваивают, букву типа. Например,
        float fet = 142.25f;  // f - float
        float feb = 254.95F;  // F - тоже float. Как больше нравится
        unsigned int upi = 25u;
        unsigned int upo = 25U;
        long double loe = 5005.5l;
        long double los = 2555.7L;
        long long ller = 1200ll;
        long long llir = 4750LL;
        unsigned long long ullpe = 6800ull;
        unsigned long long ullwe = 2510ULL;
   //   На самом деле, это наследие Си, т.к. компиляторы тех времён таким
   //   константам давали типы по умолчанию (для целых чисел это int, для
   //   вещественных - double), а потом уже приводили к типу самой
   //   инициализируемой переменной. Чтобы не делать такое лишнее приведение,
   //   к числам добавляли такие постфиксы. Это малось ускоряло компиляцию
   // auto - до C++11 это слово почти не использовалось. Оно ставилось перед
   //   объявлением переменных для задавания ей автоматической
   //   продолжительности жизни (т.е. переменная, которой автоматическая
   //   продолжительность, жила до конца блока). Как ты понял, такая
   //   продолжительность стоит у всего по умолчанию, значит auto было излишне:
   //   auto int ie = 5;
   //   но с приходом C++11 значение этого ключевого слова изменилось. Теперь
   //   оно служило чем-то вроде автотипа. Зачем писать double перед именем
   //   переменной, если Мы присваиваем ей 5.23? Это же и так понятно! Такие
   //   формальности можно оставить компилятору:
        auto obler = 5.23;
   //   Тип определяется сам, судя по значению справа. Правда, такая магия не
   //   работает в функциях просто так, т.к. компилятор не может определить
   //   тип данных во время компиляции (справа тут вообще ничего нет):
        void show(auto x)
        {
           cout << x << endl;
        }
   //   g++ просит для такого -fconcepts (он достаточно умён для колдовства).
   //   В принципе это можно использовать как облегчённую версию шаблонов, но
   //   что тогда будет происходить с перегруженными функциями? Ничего хорошего
   //   . Ещё auto можно возвращать как результат функции:
        auto get_it(int x)
        {
           return x;
        }
   //   Язык поймёт, что возвращается здесь int, но поймёт ли человек? Ведь
   //   теперь мы не можем узнать тип результата, взглянув на объявление. Для
   //   этой проблемы придумали ещё один наворот:
        auto get_char() -> char
        {
           return 'm';
        }
   //   Зачем это вообще нужно тогда? Чтобы ровно выстраивать имена функций
   //   в столбик, конечно же! Другой причины я найти не могу:
        auto get_int()   -> int {  return 42;  }
        auto get_float() -> float {  return 4.2f;  }
        auto get_pchar() -> const char* {  return "sometext";  }
   // using - этим словом можно объявялть какие-то части других пространств
   //   имён в области видимости без необходимости явно задавать членство этих
   //   частей путём ::. Например, вот так можно объявить глобально cout:
        using std::cout;
   //   Как ты знаешь, из std (или любого другого пространства имён) можно разом
   //   достать всю подноготную, используя стейтмент namespace перед ним:
        void std_use()
        {
           using namespace std;
        }                  // действие using заканчивается здесь
   //   Но теперь все конфликты имён остануться на твоей совести.
   // && - как нам известно, обычные ссылки - это просто вторые имена
   //   переменных. Ну а это вторые имена rvalue значений. При вызове функции
   //   с простым int параметром мы просто пишем в её скобках то, что нужно
   //   передать.
        int temp = get_it(2);
   //   Язык копирует твой аргумент в функцию. Так работает перемещение в Си.
   //   Управляющие C++ подумали, что такое копирование с последующим удалением
   //   старой временной 2-ки излишне и придумали ссылку для таких констант.
        auto get_it_fast(int&& x) -> int
        {
           return x;
        }
   //   int&& способен принимать только rvalue значения, вроде 2-ки или
   //   результата функции. Её жизнь, кончено, продлевается. Ввели это в C++11
   // decltype - пришло в C++11. Тоже как и auto выводит тип из контекста, но
   //   со своим механизмом:
        int thing = 25;
        decltype(thing + 6) dei = thing;
   //   Здесь в decltype мы подсунули int + 6. Значит и dei будет типа int.
   //   Фактически мы просто создали копию thing, но не упоминали его тип.
   //   Дальше интереснее. И decltype и auto ведут себя крайне неинтуитивно в
   //   чуть более сложных вещях. auto сразу отбрасывает cv-квалификаторы:
        const int coni = 9;
        auto copy = coni;  // copy теперь просто int
   //   Логика decltype с выражениями немного иная. Он берёт тип, который может
   //   вернуть выражение в его скобках:
        int i = 0;
        decltype(i)     di1;     // int
        decltype((i))   di2 = i; // &int
        decltype(i = 2) di3 = i; // &int

        const int foo() {  return 0;  }
        decltype(foo()) di4;      // int
        int&& bar() {}
        decltype(bar()) di5 = 3; // &&int
   // constexpr - в отличие от классического const, constexpr схож с #define,
   //   т.к. обрабатывается ещё во время компиляции (#define обрабатывается
   //   препроцессором). Обычный const же работает только во время компиляции.
   //   Это значит, что const может хранить, например, ввод пользователя. С
   //   constexpr такое не прокатит. Зато constexpr годен для задавания длины
   //   статического массива в определении. На самом деле GNU компиляторы (и
   //   clang) делают возможным объявление статических массивов, размер которых
   //   задаётся в runtime. Во всяком случае они делают вид, что это так
   //   (комплятор от microsoft выдаст честную ошибку). Их магия заключается в
   //   использовании VLA (variable-length arrays), где активно используется
   //   нестандартизированная функция alloca(), выделяющая память не в куче,
   //   а прямо в стёке. По непонятным причинам при такой инициализации массива
   //   обрубаются некоторые другие вещи (например, goto не сможет охватить тот
   //   кусок кода, где объявляется такой "статический" массив.


int main()
{
   int nums_a[] = { 1, 2, -1, 1 };
   int nums_b[] = { -1, 3, 0, 2, -1, 1 };
   int x = 2;

   Polynom<3> P(nums_a);

   cout << "P:        ";   P.print();
   cout << "P(" << x << "):     " << P(x) << endl;
   cout << "P':       ";   diff(P).print();
   cout << "P'(" << x << "):    " << diff(P)(x) << endl;

   Polynom<5> Q(nums_b);

   cout << "Q:        ";   Q.print();
   cout << "Q(" << x << "):     " << Q(x) << endl;

   cout << "P*Q:      ";  (P*Q).print();
   cout << "(P*Q)(" << x << "): " << (P*Q)(x) << endl;
   cout << "P+Q:      ";   (P + Q).print();
   cout << "(P+Q)(" << x << "): " << (P + Q)(x) << endl;
   cout << "Q-P:      ";   (Q - P).print();
   cout << "(Q-P)(" << x << "): " << (Q - P)(x) << endl;

   return 0;
}
