/*
 * =====================================================================================
 *
 *       Filename:  8.12_thread.cpp
 *
 *    Description:  demonstrates using of threads 
 *
 *        Version:  1.0
 *        Created:  07/01/2020 04:34:23 PM
 *       Revision:  none
 *       Compiler:  g++
 *
 *         Author:  Artur
 *   Organization:  
 *
 * =====================================================================================
 */
#include <iostream>
#include <thread>
#include <chrono>
#include <mutex>
using std::cout;
using std::endl;
using std::thread;
using std::string;
using std::mutex;

mutex m;    // mutex - класс, позволяющий что-то вроде светофоров для потоков


void mythread(string name, int time, int steps)
{
   for (int i = 1; i <= steps; i++) {
      std::this_thread::sleep_for(std::chrono::seconds(time));
      m.lock();
      cout << "thead name: " << name << "\tmessage: " << i << endl;
      m.unlock();
   }
}  // this_thread::sleep_for() - это функция для приостанавливания хода потока.
   //   Объявлен он в <thread> в пространстве имён this_thread. Принимает не
   //   int, а специальный объект, который мы получаем из chrono::seconds()
   // chrono::seconds() - функция, выдающая объект, хранящий характеристики
   //   интервала для задержки. Принимает время в секундах. Объявлена в
   //   пространстве имён chrono, доступного после подключения <chrono>
   // m.lock() - это командой поток может заблокировать проход для других. Это
   //   нужно для того, чтобы гарантировать, что код после него будет
   //   выполнятся в одно и то же время только одним потоком. Если этого не
   //   сделать, может выйти так, что во время вывода сообщения одним потоком
   //   то же самое захочет сделать другой, и получится сообщение внутри
   //   сообщения. с помощью mutex можно расставлять светофоры для потоков.
   //   Также стоит сказать, что этот светофор должен быть виден всем потокам,
   //   поэтому m здесь объявлен как глобальная переменная.
   // m.unlock() - этим можно дать зелёный свет
   // :: - странно, но нельзя подключать пространста имён как функции и классы
   //   с помощью using. Зато так лучше видно иерархию принадлежности
int main()
{
   int n = 5;
   thread A(mythread, "Alpha", 4, n);
   thread B(mythread, "Bravo", 3, n);
   mythread("Main", 2, n);
                        // thread - это класс потока. Вообще, программа идёт
   if (A.joinable()) {  //   в главном потоке (он стартует в функции main().
      A.join();         //   Здесь в нём создаются дочерние потоки A и B.
   }                    //   Конструктор потока выглядит так:
   if (B.joinable()) {  //   template <class Fn, class... Args>
      B.join();         //   explicit thread (Fn&& fn, Args&&... args);
   }                    //   Да, здесь есть несколько незнакомых вещей, но про
                        //   них чуть позже. Суть в том, что аргументами могут
   return 0;            //   быть любые вещи. Первым и обязательным аргументом
}                       //   здесь должна быть функция, с которой будет
                        //   стартовать поток. Дальше идут аргументы по желанию
                        //   , которые отправятся в функцию (они могут быть
                        //   любого типа, и их может быть сколько угодно - лишь
                        //   бы функция приняла). Ещё стоит сказать, что g++
                        //   попёрхивается thread без добавления флага -pthread
                        // joinable() - пригодится для join()
                        // join() - этот метод что-то вроде комнаты отдыха для
                        //   родительского потока. В ней он ждёт завершения
                        //   работы потока, из которого был вызван метод. Здесь
                        //   это нужно, чтобы программа не завершилась прежде,
                        //   чем её дочерние потоки не прекратят действовать.
                        //   Иначе же будет исключение и core dumped
                        // joinable() - а этот метод говорит живой ли данный
                        //   поток. Если ты попытаешься привязать (заjoinить)
                        //   уже завершившийся поток, также будет исключение
                        //   и core dumped. Лучше делать проверку
