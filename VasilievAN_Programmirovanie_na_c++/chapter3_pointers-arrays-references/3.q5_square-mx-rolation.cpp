/*
 * =====================================================================================
 *
 *       Filename:  3.q5_square-mx-rotate.cpp
 *
 *    Description: creates a square matrix and rotates it clockwise 
 *
 *        Version:  1.0
 *        Created:  05/19/20 16:44:56
 *       Revision:  none
 *       Compiler:  g++
 *
 *         Author:  Artur
 *   Organization:  
 *
 * =====================================================================================
 */
#include <iostream>
#include <cstdlib>
using namespace std;

const int dim_size = 8;

void mx_show(int _mx[dim_size][dim_size])
{
    for (int y = 0; y < dim_size; y++) {
        for (int x = 0; x < dim_size; x++)
            cout << _mx[y][x] << " ";
        cout << endl;
    }
}

int main()
{
    srand(8);

    int mx_nums[dim_size][dim_size];
        for (int y = 0; y < dim_size; y++)
            for (int x = 0; x < dim_size; x++)
                mx_nums[y][x] = rand() % 10;
        mx_show(mx_nums);
        cout << endl;

    int max_lvl,      // max    - max для текущего уровня. Уровень - это как-бы
        buf,          //          оболочка матрицы - как слои у Земли
        max_id =      // buf    - хранилище для какого-то элемента. Элементы
         dim_size - 1;//          меняются покругу. Например, верхним первым
                      //          станет тот, который был левым нижний, а им,
                      //          в свою очередь, тот, что был справа снизу.
                      //          4 5 -> 2 4 Цикл начинает с замены верхнего
                      //          2 3    3 5 ряда, поэтому все верхнии элементы
                      //          текущей оболочки по очереди хранятся в буфере
                      // max_id - просто максимальный индекс
    for (int lvl = 0; lvl < dim_size/2; lvl++) {
        max_lvl = (dim_size - lvl) - 1;
                        // lvl - это показатель уровня. Если мы хотим
                        //       получить элемент в массиве, то просто
                        //       добовляем к ниму префикс lvl для каждого
                        //       измерения, а затем его координаты по уже
                        //       внутренней системе координат.
                        //                  5 2 5 6 /
                        //                  5 3 2 /
                        //                  3 1 /
                        //                  9 /
                        //                  ^
                        //         нулевой lvl, т.е. [..][0 + x] по оси x
                        // max - это максимальный id для текущего уровня
        // здесь меняются элементы по кругу, по очереди с каждой грани.
        // За один проход меняются соответсвтующие элементы. Почему 
        // dim_size - lvl - 1? Когда мы уже прошлись по всем элементам каждой
        // грани и добрались до последнего, то этот последний элемент не стоит
        // трогать, т.к. он уже был готов после первого прохода, т.к. последний
        // элемент одной грани - начальный элемент другой, а начальные элементы
        // у всех мы уже потрогали. Да, есть max_lvl, но он здесь не причём
        for (int i = lvl; i < (dim_size - lvl) - 1; i++) { 
            buf = mx_nums[lvl][i];  // это элементы верхней грани по очереди
            mx_nums[lvl][i]              = mx_nums[max_id - i][lvl];
            mx_nums[max_id - i][lvl]     = mx_nums[max_lvl][max_id - i];
            mx_nums[max_lvl][max_id - i] = mx_nums[i][max_lvl];
            mx_nums[i][max_lvl]          = buf; // т.к. элементы верхней грани
        }                                       // мы уже прошли, то берём
    }                                           // нашу запаску

    mx_show(mx_nums);
    return 0;
}
