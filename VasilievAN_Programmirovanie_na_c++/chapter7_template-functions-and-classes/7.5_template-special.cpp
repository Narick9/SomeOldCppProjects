/*
 * =====================================================================================
 *
 *       Filename:  7.5_template-special.cpp
 *
 *    Description:  demonstrates a explicit specialization template func 
 *
 *        Version:  1.0
 *        Created:  06/21/20 18:23:14
 *       Revision:  none
 *       Compiler:  g++
 *
 *         Author:  Artur
 *   Organization:  
 *
 * =====================================================================================
 */
#include <iostream>
using namespace std;


class MyClass {
   public:
      int num;

      MyClass(int _num) {
         num = _num;
      }

      void show() {
         cout << "MyClass object: " << num << endl;
      }
};


template <class T>
void show(T thing)
{
   cout << thing << endl;
}
template<>
void show<int>(int n)            // <><int> - так выглядит явная специализация
{                                //   шаблонной функции. Логика компилятора
   cout << "int: " << n << endl; //   такова, что при вызове функции, допустим,
}                                //   с char, он объявляет "конкурс".
template<>                       //   Сначала конкурируют между собой шаблонные
void show<MyClass>(MyClass obj)  //   и нешаблонные функции. Причём в
{                                //   приоритете именно нешаблонные (обычные
   obj.show();                   //   классические функции, сюда относятся и
}                                //   перегруженные). Если победила именно
                                 //   шаблонная функция, то дальше уже берутся
                                 //   во внимание её специализированные версии
int main()                       //   (да, специализированные версии привязаны
{                                //   к своим "базовым" шаблонам). Если среди
   show('A');                    //   них нет подходящего, то побеждает базовый
   show(100.0);                  //   шаблон. Тут стоит сказать о нюансах.
   show(200);                    //   template< class T > void func(T..)  #1
                                 //   template< class T > void func(T*..) #2
   MyClass obj(300);             //   template<> void func<int*>(int*..)  #3
   show(obj);                    //   Здесь спициализированный шаблон #3 будет
                                 //   относится к первому подходящему
   return 0;                     //   встречному сверху, т.е. здесь это #3. Но
}                                //   если слегка изменить порядок, как здесь:
                                 //   template< class T > void func(T..)  #1
                                 //   template<> void func<int*>(int*..)  #3
                                 //   template< class T > void func(T*..) #2
                                 //   то здесь первым подходящим встречным
                                 //   станет #1 (ведь int* - это тоже отдельный
                                 //   тип, как и простой int). Поэтому, чтобы
                                 //   избегать таких неприятностей, то стоит
                                 //   отдать предпочтение именно простой и
                                 //   понятной перегрузке. Явная специализация
                                 //   создавалась в первую очередь для классов,
                                 //   где она полезна (об этом чуть позже),
                                 //   поэтому она существует
